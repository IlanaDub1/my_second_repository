# -*- coding: utf-8 -*-
"""08 applied python: pathlib module, files.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RHmDJsCAovxJN9wUepzfd1-itfOUhgz0

# Learning a new python module

> three simple things:

1. which _important_ classes/types are in the module
2. what are the _most useful_  constructors and methods for these classes
3. any useful functions and constants in the module

To effectively grasp a new Python module, leveraging tutorials for both foundational understanding and practical application is crucial. Here's an integrated approach:

**1. Immerse in Tutorials for Comprehension and Context:** Begin with well-written tutorials from resources like [realpython](realpython.com). These provide an engaging narrative that explains why the module is useful, illustrating its practical applications and benefits. Through these narratives, you'll find context for the module's existence and its place within Python's ecosystem.

**2. Interactive Code-Along:** Enhance your learning by coding alongside the tutorials. By typing out and running the code, youâ€™re more likely to _actually learn_ and retain the information.

**3. Experimentation in a Python Session:** Take what youâ€™ve learned to an interactive Python session like Google Colab, and just try stuff out.

**4. Deep Dive into Reference Documentation:** For a comprehensive understanding, turn to the official Python documentation on [python.org](python.org). Itâ€™s an excellent reference for all the nitty-gritty details of the module's capabilities, including an exhaustive list of functions, classes, and methods.

> Incorporating these steps into your learning process bridges the gap between theoretical knowledge and practical expertise. Tutorials set the stage, documentation fills in the details, and hands-on coding ties everything together, giving you a well-rounded comprehension of the module and its place in your Python programming toolbox.

# the import statement

variations on the `import` statement

```python
import MODULE
from MODULE import NAME1, NAME2, ..., NAME_n
from MODULE import NAME1 as OTHER1, ... NAME_n as OTHER_n
```

### Variations of the `import` Statement
1. **`import MODULE`:**
   - Example: `import math`, then use `math.sqrt()`.

2. **`from MODULE import NAME1, NAME2, ..., NAME_n`:**
   - Example: `from math import sqrt`, then use `sqrt()` directly.

3. **`from MODULE import NAME1 as OTHER1, ... NAME_n as OTHER_n`:**
   - This imports items with an alias.
   - Useful if the original name is long or conflicts with other names.
   - Example: `from math import sqrt as square_root`, then use `square_root()`.

### RATIONALE:

The `from MODULE import NAME` syntax serves several purposes:

- **Reduces Typing:** It allows you to use functions, classes, etc., directly without prefixing them with the module name. This reduces typing and can make code clearer.
  
- **Avoids Namespace Conflicts:** It lets you bring in only the specific items you need, reducing the chance of name conflicts with items defined in your code or other imported modules.

- **Improved Readability:** Code can be more readable when you don't have to repeatedly type the module name.
"""

import math
math.cos(0)  # 1
import math as m
m.cos(0)  # 1
from math import cos
cos(0)  # 1
from math import cos, sin, tan
x =23423
cos(x)**2 + sin(x)**2  # 1

pi = 'lemon keylime'
from math import pi
print(pi)

import datetime as dt
from datetime import datetime as DT
DT(2023, 11, 15)

"""### Understanding the `Path` Object from `pathlib`

- **Introduction to `pathlib`:**
  - `pathlib` provides easy-to-use classes to handle filesystem paths.
  - It allows for more readable and maintainable code.
- Importing pathlib:
"""

# import pathlib
# and use the pathlib.Path constructor
import pathlib
p = pathlib.Path('/content/sample_data')
print(p)

# but we can put the pathlib.Path class
# into a new variable with shorter name
Path = pathlib.Path
print(Path)
p = Path('/content/sample_data')
print(p)

# can even make really short names
P = pathlib.Path
p = P('/content')
print(p)

from pathlib import Path

### the statement above ...
### will actually run the code below
# import pathlib
# Path = pathlib.Path
# del pathlib

"""- Creating a Path Object:

  - Used to represent file paths and folders.
  - Can work with both Windows and Unix path formats.

"""

p = Path('.')  # symbolic reference to current directory
print("Current directory:", p)
print("Current directory:", p.absolute())  # absolute path

"""- Listing Files in a Directory:

  - You can list all files in a directory.
"""

p = Path('/content/sample_data/')
for file in p.iterdir():
    print(file)

"""- Checking if Path Exists:
  - To check if a path exists.
"""

a = Path('/content/sample_data/README.md')
b = Path('not_an_existing_file.txt')

for p in [a, b]:
    if p.exists():
        print("Path exists", p)
    else:
        print("Path does not exist", p)

# windows: '.\new_folder'
# linux: './new_folder'

p = Path('.')
new_dir = p / 'new_folder'
print(new_dir.absolute())
new_dir.mkdir(exist_ok=True)
print("New directory created:", new_dir)

type(p)

### the variable Path is actually
### either PosixPath or WindowsPath

# if OS == 'windows':
#     Path = WindowsPath
# else:
#     Path = PosixPath

file_path = p / 'example.txt'
file_path.write_text("Hello, Pathlib!")
print("File written:", file_path)

# Example (reading):
content = file_path.read_text()
print("File content:", content)


# Combine paths, get parent directory, etc.
parent_dir = p.parent
print("Parent directory:", parent_dir)
combined_path = parent_dir / 'new_file.txt'
print("Combined path:", combined_path)

p = Path('sample_data/README.md').absolute()
print(p)
print(p.parent)
print(p.parent.parent)
print(p.parent.parent.parent)

"""# Using `Path` from `pathlib` on Your Own Computer with JupyterLab

JupyterLab is an interactive development environment that allows you to work with Jupyter notebooks. It's similar to Google Colab but runs on your own computer. This gives you more control and lets you work with files directly on your machine.

## What is JupyterLab?

- **Interactive Environment:** JupyterLab lets you write and run code in an interactive way.
- **Supports Notebooks:** It uses Jupyter notebooks (.ipynb files), which combine code, text, and visuals.
- **Flexible and Extensible:** You can customize it with extensions and integrate it with other tools.
- **Great for Learning:** It's perfect for experimenting with Python and libraries like `pathlib`.

## How to Install JupyterLab

To get JupyterLab up and running on your computer, follow these simple steps:

1. **Open Terminal or Command Prompt:**
   - This is where you'll type the installation commands.

2. **Install JupyterLab:**
   - In the terminal, type:
     ```
     pip install jupyterlab
     ```
   - This command uses `pip`, Python's package installer, to download and install JupyterLab.

3. **Wait for Installation:**
   - It might take a few minutes to install. You'll see progress in the terminal.

## Running JupyterLab

After installing JupyterLab, it's easy to start using it:

1. **Launch JupyterLab:**
   - In the same terminal, type:
     ```
     jupyter lab
     ```
   - This command starts JupyterLab on your computer.

2. **Use JupyterLab:**
   - Your web browser will open with JupyterLab running.
   - You can create a new notebook to start writing Python code.

3. **Experiment with `Path`:**
   - In your new notebook, you can import `Path` from `pathlib` and start experimenting.

Remember, with JupyterLab running on your computer, you can easily work with local files and directories, making it ideal for learning and experimenting with `Path` from `pathlib`. It's a powerful tool for both beginners and experienced programmers.

# Your turn

1. create a `Path()` object put in variable `p`
2. print the `p` object
3. create files
4. write into files
4. create directories
5. rename files
6. read files
7. delete files

### Task 1: Create a `Path()` Object
- **Task:** Initialize a `Path` object and assign it to a variable `p`.
- **Hint:** `Path()` without arguments defaults to the current directory.

### Task 2: Print the `p` Object
- **Task:** Display the contents of the `p` object.
- **Hint:** Use the `print()` function to see the representation of `p`.

### Task 3: Create Files
- **Task:** Create a file named 'my_document.txt'.
- **Hint:** Use `p / 'my_document.txt'` to create a new path and `touch()` to create the file.

### Task 4: Write Data into Files
- **Task:** Write the text "Hello, pathlib!" into 'my_document.txt'.
- **Hint:** Use `write_text()` for writing. For appending, read the content first, then write back the old content plus the new content.

### Task 5: Create Directories
- **Task:** Make a new directory named 'my_folder'.
- **Hint:** Use `mkdir()` method on the path `p / 'my_folder'`.

### Task 6: Rename Files
- **Task:** Change the name of 'my_document.txt' to 'updated_document.txt'.
- **Hint:** Use the `rename()` method on the file path.

### Task 7: Read Files
- **Task:** Read the contents of 'updated_document.txt'.
- **Hint:** Use the `read_text()` method on the file path.

### Task 8: Delete Files
- **Task:** Remove the file 'updated_document.txt'.
- **Hint:** Use the `unlink()` method to delete the file.

### Additional Challenge: Absolute vs. Relative Paths
- **Task:** Compare the output of `p.resolve()` with `p`. What do you observe?
- **Hint:** `resolve()` gives the absolute path, whereas `p` might be relative.

> Through these tasks, you'll gain practical experience with file and directory management using `Path` in Python. They'll also help you understand the concepts of absolute and relative paths, as well as how to append to files instead of overwriting them.
"""



"""# solution"""

from pathlib import Path

# Task 1: Create a Path() object
p = Path()
print("Task 1: Created a Path object representing the current directory:", p)

# Task 2: Print the p Object
print("\nTask 2: Printing the Path object 'p' shows the current directory:", p)

# Task 3: Create Files
file_path = p / 'my_document.txt'
file_path.touch()  # Creates the file
print("\nTask 3: File 'my_document.txt' created at path:", file_path)

# Task 4: Write Data into Files
file_path.write_text("Hello, pathlib!")
print("\nTask 4: Written 'Hello, pathlib!' into 'my_document.txt'.")

# Append more lines to the file
file_path.write_text(file_path.read_text() + "\nmore lines!")
print("Appended 'more lines!' to 'my_document.txt'.")
print("Current contents of 'my_document.txt':\n", file_path.read_text())

# Task 5: Create Directories
dir_path = p / 'my_folder'
dir_path.mkdir(exist_ok=True)  # Creates the directory
print("\nTask 5: Directory 'my_folder' created at path:", dir_path)

# Task 6: Rename Files
new_file_path = p / 'updated_document.txt'
file_path.rename(new_file_path)  # Renames the file
print("\nTask 6: File 'my_document.txt' renamed to 'updated_document.txt'.")

# Task 7: Read Files
content = new_file_path.read_text()
print("\nTask 7: Content of 'updated_document.txt':\n", content)

# Task 8: Delete Files
new_file_path.unlink()  # Deletes the file
print("\nTask 8: File 'updated_document.txt' deleted.")

# Additional Challenge: Absolute vs. Relative Paths
absolute_path = p.resolve()
print("\nAdditional Challenge: Absolute path of 'p':", absolute_path)

"""# More Tasks with `Path` in Python

### Task 9: List Specific File Types in a Directory

**Task:** Create five files in the current directory: three with a `.txt` extension ('document1.txt', 'document2.txt', 'notes.txt') and two with different extensions ('image.jpg', 'data.csv'). Then, list all files with the `.txt` extension in the current directory.

**Hints:**
- Use the `touch()` method of the `Path` object to create each file.
- After creating the files, use the `glob()` method with the pattern `'*.txt'` to find all text files.
- The pattern `'*.txt'` matches any filename that ends with `.txt`, making it a useful tool to filter files by their extension.

**Steps:**
1. Create the files 'document1.txt', 'document2.txt', 'notes.txt', 'image.jpg', and 'data.csv'.
2. Use `glob()` with the `'*.txt'` pattern to list all text files in the current directory.

**Short Explanation of the Pattern `*.txt`:**
- `*` in the pattern `'*.txt'` is a wildcard character that matches any sequence of characters.
- `.txt` ensures that only files ending with this extension are matched.
- Combined, `'*.txt'` will match any file regardless of its name, as long as it ends with `.txt`.

> This task demonstrates how to create files with specific extensions and use the `glob()` method to efficiently find a subset of these files based on their extension. It is a common pattern in file operations, especially when dealing with directories containing various types of files.

### Task 10: Check if a File Exists
**Task:**
1. Create a file named 'example.py' in the current directory.
2. Check if 'example.py' exists.
3. Delete 'example.py'.
4. Check again if 'example.py' exists.

**Hints:**
- Use the `touch()` method to create 'example.py'.
- Use the `exists()` method on the path `p / 'example.py'` to check its existence.
- Use the `unlink()` method to delete the file.


### Task 11: Get File Size
**Task:**
1. Create a file named 'hello.txt' and write some content to it.
2. Find the size of 'hello.txt' in bytes.

**Hints:**
- Use the `write_text()` method to create 'hello.txt' with some content, like "Hello World".
- Use the `stat()` method and access the `st_size` attribute to find the file size.

**Example Content for 'hello.txt':**
- "Hello World"

### Task 12: Copy a File
- **Task:** Copy 'hello.txt' to a new file 'hello_copy.txt'.
- **Hint:** `pathlib` doesnâ€™t have a direct copy method. Use `shutil.copy()` from the `shutil` module.

### Task 13: Moving a File
- **Task:** Move 'hello_copy.txt' to a directory 'my_folder'.
- **Hint:** Use `rename()` method, but remember to provide the full new path.

### Task 14: Creating Nested Directories
- **Task:** Create a series of nested directories like 'dir1/dir2/dir3'.
- **Hint:** Use `mkdir(parents=True)` to create all parent directories.

### Task 15: Traverse Through Parent Directories of a Nested Directory

**Task:**
Using the nested directories created in Task 14 ('dir1/dir2/dir3'), traverse through and print each parent directory until you reach the root directory.

**Hints:**
- Start with the `Path` object representing 'dir1/dir2/dir3' from `task 14`
- Use a while loop to go up each level of the directory structure by accessing the `.parent` attribute of the `Path` object.
- Stop the loop when you reach the root directory (when the current directory's parent is the same as itself).

>This revised task will help demonstrate how to navigate through a directory tree using the `.parent` attribute

### Task 16: Resolve Relative Paths to Absolute Paths

**Task Description:**
Create a sibling directory named 'dir2_brother' alongside 'dir2' within the nested structure 'dir1/dir2/dir3'. Then, change your current working directory to 'dir1/dir2', create a Path object for '../dir2_brother', and use it to create a new file in the 'dir2_brother' directory. Finally, print the full path of the new file using the `.absolute()` method.

**Hint & Steps:**
1. Create the directory 'dir1/dir2_brother' as a sibling to 'dir2'.
2. Change the current working directory to 'dir1/dir2'. please `import os` and use `os.chdir` for this.
3. Create a `Path` object representing the path to the sibling directory ('../dir2_brother').
4. Use this `Path` object to create a new file in the 'dir2_brother' directory.
5. Print the full path of the new file using the `.absolute()` method to verify that the file was created in the correct location.

> This task will help you understand how to navigate file systems using relative paths

### Task 17: Iterate Through Files and Directories
- **Task:** Print all files and directories within the `/content` directory.
- **Hint:** Use `iterdir()` and distinguish between files and directories with `is_file()` and `is_dir()`.



### Task 18: File Extension and Name
- **Task:** Print the file name and extension separately for every file you found on task 17
- **Hint:** Use the `stem` and `suffix` attributes.

"""



"""# Solution"""

# Task 9: Create files and list all .txt files in the directory

from pathlib import Path

# Create a Path object for the current directory
p = Path()

# File names to create
file_names = ['document1.txt', 'document2.txt', 'notes.txt', 'image.jpg', 'data.csv']

# Creating the files using the touch method
for file_name in file_names:
    (p / file_name).touch()

print("Created files:", file_names)

# Using glob to list all .txt files
txt_files = list(p.glob('*.txt'))
print("Text files in the directory:")
for txt_file in txt_files:
    print(txt_file)

# Task 10: Check if a File Exists, Then Delete and Check Again

# Create a Path object for the current directory
p = Path()

# Step 1: Create the file 'example.py'
example_file = p / 'example.py'
example_file.touch()
print("Created 'example.py'.")

# Step 2: Check if 'example.py' exists
print("'example.py' exists:", example_file.exists())

# Step 3: Delete 'example.py'
example_file.unlink()
print("'example.py' deleted.")

# Step 4: Check again if 'example.py' exists
print("'example.py' exists after deletion:", example_file.exists())

# Task 11: Create a File with Content, Then Get Its Size

# Create a Path object for the current directory
p = Path()

# Step 1: Create 'hello.txt' with content
hello_file = p / 'hello.txt'
hello_file.write_text("Hello World")
print("Created 'hello.txt' with content.")

# Step 2: Find the size of 'hello.txt' in bytes
print("Size of 'hello.txt':", hello_file.stat().st_size, "bytes")

# Task 12: Copy a File
import shutil

print("\nTask 12: Copy 'hello.txt' to 'hello_copy.txt'.")
hello_copy = p / 'hello_copy.txt'
shutil.copy(hello_file, hello_copy)
print("File 'hello.txt' copied to 'hello_copy.txt'.")

# Task 13: Moving a File
print("\nTask 13: Move 'hello_copy.txt' to the 'my_folder' directory.")
my_folder = p / 'my_folder'
hello_copy_new_path = my_folder / 'hello_copy.txt'
shutil.move(hello_copy, hello_copy_new_path)
print("'hello_copy.txt' moved to 'my_folder'.")

# Task 14: Creating Nested Directories
print("\nTask 14: Create nested directories 'dir1/dir2/dir3'.")
nested_dirs = p / 'dir1/dir2/dir3'
nested_dirs.mkdir(parents=True, exist_ok=True)
print("Nested directories created: 'dir1/dir2/dir3'.")

### Task 15

# Assuming 'dir1/dir2/dir3' is already created as per Task 14
# Start with the innermost directory 'dir3' in 'dir1/dir2/dir3'
current_directory = Path('dir1/dir2/dir3')
assert current_directory.exists()
assert current_directory.is_dir()

# Print each parent directory until you reach the root
print("Traversing through parent directories:")
while current_directory != current_directory.parent:
    # Move up one level
    current_directory = current_directory.parent
    # Print the parent directory
    print(current_directory)

# Task 16: Resolve Relative Paths to Absolute Paths
from pathlib import Path
import os

print("Starting Task 16...")

# Step 1: Create the directory 'dir1/dir2_brother' as a sibling to 'dir2'
dir1 = Path('dir1')
dir2_brother = dir1 / 'dir2_brother'
dir2_brother.mkdir(parents=True, exist_ok=True)
print(f"Created directory: {dir2_brother}")

# Step 2: Change the current working directory to 'dir1/dir2'
# (Assuming 'dir1/dir2' exists)
os.chdir(dir1 / 'dir2')
print(f"Changed current working directory to: {os.getcwd()}")

# Step 3: Create a Path object for '../dir2_brother' and use it to create a new file
new_file_path = Path('../dir2_brother/new_file.txt')
new_file_path.touch()
print(f"Created new file at: {new_file_path}")

# Step 4: Print the full path of the new file using .absolute()
absolute_path = new_file_path.absolute()
print(f"Full path of the new file: {absolute_path}")

print("Task 16 completed.")

### Task 17

# Create a Path object for the current directory
current_dir = Path('/content')

print("Task 17: Listing all files and directories in the current directory.")
for item in current_dir.iterdir():
    if item.is_file():
        print(f"File: {item}")
    elif item.is_dir():
        print(f"Directory: {item}")

### Task 18

print("\nTask 18: Printing file name and extension for each file.")

for item in current_dir.iterdir():
    if item.is_file():
        print(f"File Name: {item.stem}, Extension: {item.suffix}")

"""# Raw Strings in Python

Raw strings in Python are a convenient way to handle strings that contain backslashes (`\`) without needing to escape them. They are often used for regular expressions, file paths, and other scenarios where you don't want Python to treat backslashes as escape characters.

### Motivation:
Consider what happens when you print a normal string containing `"\\"`:

```python
print("\\")  # This will print a single backslash
```

In a regular string, a backslash is an escape character, used to denote special characters like newlines (`\n`) or tabs (`\t`). So, to print a single backslash, you need to escape it using another backslash.

### Using Raw Strings:
In raw strings, prefixed with `r` or `R`, backslashes are treated as literal characters and do not need to be escaped.

```python
print(r"in this raw string \n and \t are just letters without special meaning")
```

This will print the string exactly as it is, with `\n` and `\t` as part of the string, not as newline and tab characters. Raw strings ignore escape characters, making them very useful when you need the string to exactly represent what you write, such as in regular expressions or file paths.
"""

print("\\") # \

"""what happens when you print `"c:\new_folder"` ?"""

print("c:\new_folder")

### SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \uXXXX escape
# print("c:\users\aviad\new_folder")
print("c:\\users\\aviad\\new_folder")

print(r"c:\users\aviad\new_folder")

print(r"\\")

s = r"\\"
type(s), len(s), s

s = "\\"
type(s), len(s), s

"""# Opening, Reading, and Writing to Files Using the `open` Function

Working with files involves understanding file handles and their interaction with the underlying operating system. File handles are an abstraction provided by the operating system to interact with files. Their properties and behavior are largely dictated by the OS, and their concept is rooted in historical data storage practices, particularly those involving magnetic tape in the 1970s. Despite advancements in technology, the fundamental principles behind file handling have not evolved significantly, maintaining a consistent interface for programmers.

When it comes to interacting with files, there are numerous methods available. However, the patterns shown below for reading from and writing to files are the most common and practical. They are relevant and applicable 99% of the time in various programming scenarios.

### Open for Reading, and Read Line by Line
This method opens a file for reading and processes it line by line. It's useful for handling large files or processing each line individually.

```python
f = open(FILENAME)
for line in f:
    # do stuff with the line
f.close()  # Always remember to close the file
```

### Open for Writing, Write Stuff
Here, the file is opened in write mode ('w'). This mode is used for writing content to a file. If the file already exists, it will be overwritten.

```python
f = open(FILENAME, "w")
print(..., file=f)
f.close()  # Closing the file to ensure data is written and file is released
```

### Open for Appending (Adding at the End)
Opening a file in append mode ('a') allows you to add content to the end of the file without altering the existing content.

```python
f = open(FILENAME, "a")
print(..., file=f)
f.close()  # Don't forget to close the file
```

### The Importance of `.close()` in File Operations

Understanding why `.close()` is essential in file handling relates to how operating systems manage file writing operations. Operating systems, in an effort to optimize performance, often delay writing data to the disk. This delay is because writing to a disk is significantly slower (by a factor of thousands) compared to writing to memory. As a result, when you write data to a file in your program, it's not uncommon to find that the data hasn't actually been written to the disk immediately.

#### Why `.close()` Matters:
- **Flushing Data:** When you call `.close()`, it signals the operating system that you're done with the file. More importantly, it triggers the OS to _flush_ all buffered data to the disk. Flushing is the process of writing all pending data to the permanent storage, ensuring that all your changes are saved as expected.
- **Resource Management:** Open file handles are limited resources in your system. Failing to close a file handle can lead to resource leaks, which might prevent you or other programs from opening more files later.
- **Data Integrity:** If your program crashes or the system experiences a power failure before `.close()` is called, the data might not be saved correctly, leading to data loss or corruption. Explicitly closing the file minimizes this risk.

"""

# open the file for reading
f = open('sample_data/california_housing_train.csv')
print(f)  # operating system file handle object

# f.read() # read the entire file and return as str
# f.readlines() # read the entire file, and return as list of string
f.readline()  # read the NEXT line in the file

f.readline()

f = open('sample_data/california_housing_train.csv')

i = 1
for line in f:
    print(i, "\t", line[:30], '...')

    i+=1
    if i>10:
        break

#        filename,       mode
# mode="w" --> write
f = open('new_file.txt', "w")
# f.write("line1\n") # write text into the file
### write each item in a list of texts to file
# f.writelines(["line2\n", "line3\n"])
print("line1", file=f)
for text in ["line1", "line2"]:
    print(text, file=f)
f.close()

print(open("new_file.txt").read())

# opening the for writing completely destroys
# any existing data in the file
f = open('new_file.txt', "w")
print(open("new_file.txt").read())  # NOTHING

"""```
A FILE THAT BIG?
MIGHT BE USEFUL
BUT NOW ITS GONE
```

> https://www.gnu.org/fun/jokes/error-haiku.en.html
"""

f = open('example.txt', 'w')
f.write('hello!')
# f.close()  # also flushes the data into the file
print(open("example.txt").read())  # NOTHING

"""## `with` statement: how to not forget to .close() files?

```python
with open(FILENAME, "w") as f:
    ... # do stuff with the file
    ... #

# here the file is closed
print('done')
```

or more generically:

```python
with EXPRESSION as NEW_VARIABLE:
    ... # do stuff
    ... # with the variable

... # here the with is finished and the object gets "closed"
```

## `with` statement: How to Automatically Close Files in Python

The `with` statement in Python provides a cleaner and more concise way to handle file operations, ensuring that files are automatically closed once the block of code is exited. This approach is particularly useful because it eliminates the need to explicitly call `.close()` on the file object, thereby reducing the risk of leaving files open unintentionally and causing resource leaks.

### How the `with` Statement Works
When you use the `with` statement to open a file, Python creates what is known as a context manager. This context manager takes care of opening the file when entering the block and, most importantly, closing the file when exiting the block, regardless of how the block is exited (whether normally or via an exception).

#### Example Usage
```python
with open(FILENAME, "w") as f:
    # Perform file operations
    # You can write to the file, read from it, etc.
    # ...

# At this point, the file is automatically closed
print('File operations complete, file closed')
```

#### Advantages of Using `with`
- **Automatic File Closure:** The file is automatically closed when the block is exited, which is a significant advantage, especially in scenarios where your code may raise exceptions.
- **Better Resource Management:** It helps in preventing resource leaks by ensuring that the file is closed even if an error occurs during file operations.
- **Code Readability and Clarity:** The `with` statement makes it clear that the file usage is confined to the block, enhancing the readability and maintainability of your code.

In summary, using the `with` statement for file handling in Python is a best practice that simplifies your code and eliminates the need to remember to close your files, thereby making your code more robust and error-free.
"""

with open('example.txt', 'w') as f:
    print('hello!', file=f)
    for i in range(1,10+1):
        print('@' * i, file=f)

# close happens automatically
print(open("example.txt").read())  # hello!

# in this example, experiement by changing mode from "w" to "a"
mode = "w"
with open('append_example.txt', mode) as f:
    print('hello', file=f)

mode = "a"
with open('append_example.txt', mode) as f:
    print('goodbye', file=f)

print(open('append_example.txt').read())

"""

### Exercise 1: Write to a File
**Task:** Create a file named `greetings.txt` and write the sentence "Hello, Python world!" to it.

**Hints:**
- Use the `with` statement to open the file in write mode (`"w"`).
- Use the `write()` method to add text to the file.

### Exercise 2: Read from a File
**Task:** Open the file `greetings.txt` created in Exercise 1 and print its contents to the console.

**Hints:**
- Open the file in read mode (`"r"`).
- Use a `for` loop or the `read()` method to read the contents.
- Print the contents.

### Exercise 3: Append to a File
**Task:** Append the sentence "I'm learning file handling in Python!" to the `greetings.txt` file.

**Hints:**
- Open the file in append mode (`"a"`).
- Use the `write()` or `print()` method to add the new sentence to the file.

### ðŸŒ¶ï¸ðŸŒ¶ï¸ðŸŒ¶ï¸ Exercise 4: Write and Read Person Data to/from a File

**Task:** Create a list of dictionaries, each representing a person with their `name`, `age`, and `height`. Write this data to a file in a human-readable format, and then read it back, parsing the data to reconstruct the list of dictionaries.

**Data Example:**
```python
people = [
    {"name": "Alice Smith", "age": 30, "height": 5.5},
    {"name": "Bob Johnson", "age": 45, "height": 6.1},
    {"name": "Carol Williams", "age": 22, "height": 5.3},
    {"name": "David Brown", "age": 35, "height": 5.9}
]
```

#### Writing Data to a File
**Hints:**
- Use the `with` statement to open a file in write mode.
- Format each person's data into a string and write it to the file.
- Separate each person's data with a newline character.
- Simplifying Assumption: Names contain only alphabetical characters and spaces.

#### Example File Format:
```
Alice Smith, 30, 5.5
Bob Johnson, 45, 6.1
Carol Williams, 22, 5.3
David Brown, 35, 5.9
```

#### Reading Data from the File
**Hints:**
- Open the file in read mode and read its content.
- Use a `for` loop to iterate over each line in the file.
- Split each line by the comma to separate the fields.
- Convert age and height to their appropriate data types (int and float, respectively).
- Reconstruct the list of dictionaries from the file data.

> By completing this exercise, you will practice more advanced file operations, including custom data formatting and parsing without relying on external libraries like JSON. This will enhance your understanding of string manipulation and file I/O in Python."""



"""# solution"""

# Exercise 1: Write to a File
with open("greetings.txt", "w") as file:
    print("Hello, Python world!", file=file)
    print("thank you python", file=file)

# Exercise 2: Read from a File
with open("greetings.txt", "r") as file:
    for line in file:
        print(line.strip())

# Exercise 3: Append to a File
with open("greetings.txt", "a") as file:
    print("\nI'm learning file handling in Python!", file=file)

print(open("greetings.txt").read())

# Exercise 4: Write and Read Person Data to/from a File
people = [
    {"name": "Alice Smith", "age": 30, "height": 5.5},
    {"name": "Bob Johnson", "age": 45, "height": 6.1},
    {"name": "Carol Williams", "age": 22, "height": 5.3},
    {"name": "David Brown", "age": 35, "height": 5.9}
]

# Writing Data to a File
with open("people.txt", "w") as f:
    for person in people:
        print(
            # Alice Smith, 30, 5.5
            f"{person['name']}, {person['age']}, {person['height']}",
            file=f
            )

# Reading Data from the File and Reconstructing the List
read_people = []
with open("people.txt", "r") as file:
    for line in file:
        name, age, height = line.strip().split(", ")
        read_people.append({"name": name, "age": int(age), "height": float(height)})

# Print the reconstructed list to verify
for person in read_people:
    print(person)

"""# JSON

JSON (JavaScript Object Notation) is a format for structuring data, using conventions that are familiar to programmers. It's essentially text that can be converted into  lists and dictionaries in python.

### How JSON Looks Like:

```python
people = [
    {"name": "Alice Smith", "age": 30, "height": 5.5},
    {"name": "Bob Johnson", "age": 45, "height": 6.1},
    {"name": "Carol Williams", "age": 22, "height": 5.3},
    {"name": "David Brown", "age": 35, "height": 5.9}
]

banks = [
    {'name': 'hapoalim', 'rating': 7},
    {'name': 'discount', 'rating': 8}
]

db = {
    'people': people,
    'banks': banks,
}
```

If this Python data is converted to a JSON format, it will look remarkably similar:

```json
{
    "people": [
        {"name": "Alice Smith", "age": 30, "height": 5.5},
        {"name": "Bob Johnson", "age": 45, "height": 6.1},
        {"name": "Carol Williams", "age": 22, "height": 5.3},
        {"name": "David Brown", "age": 35, "height": 5.9}
    ],
    "banks": [
        {"name": "hapoalim", "rating": 7},
        {"name": "discount", "rating": 8}
    ]
}
```

### JSON as Text Representing Objects:

- **Textual Representation:** JSON is a text format. When you see a JSON file, it's a plain text file, but structured in a way that's readable, editable and understandable both by humans and computers.

- **Objects Creation:** The JSON format is essentially representing  dictionaries, lists, strings, and numbers in Python. When this text is read by a Python program, it can be directly converted into Python objects.
  > the same is true for JavaScript and many other languages.

- **Python and JavaScript Syntax:** The syntax for representing objects, lists, strings, and numbers in JSON is identical to the syntax in Python and JavaScript for creating these data structures.

### Motivation for JSON:
1. **Easy to Understand and Edit:** Developers find it easy to read and manually edit JSON files, which is especially useful during debugging or configuration.

2. **Flexibility:** JSON is inherently flexible. It allows for a recursive structure - dictionaries within lists, lists within dictionaries, and so on. This makes JSON capable of representing very complex data structures

3. **Database Representation:** JSON can represent database-like structures. A single JSON can represnt a table in a DB, or even ALL the tables in the DB.

### Key JSON Functions:
- **`dump` and `dumps`:**
  - `json.dump(object, file)` writes JSON data to a file-like object.
  - `json.dumps(object)` (dump string) converts Python objects into a JSON string.
- **`load` and `loads`:**
  - `json.load(file)` reads JSON data from a file-like object and converts it into Python objects.
  - `json.loads(text)` (load string) converts a JSON string into Python objects.

In summary, JSON's human-readable format, combined with its flexibility and compatibility with modern database technologies, makes it an ideal choice for data interchange and storage in a wide range of applications.
"""

people = [
    {"name": "Alice Smith", "age": 30, "height": 5.5},
    {"name": "Bob Johnson", "age": 45, "height": 6.1},
    {"name": "Carol Williams", "age": 22, "height": 5.3},
    {"name": "David Brown", "age": 35, "height": 5.9}
]

banks = [
    {'name' : 'hapoalim', 'rating': 7},
    {'name' : 'discount', 'rating': 8}
]

db = {
    'people' : people,
    'banks' : banks,
}

import json

data_representation = json.dumps(db)
print(data_representation)

with open('database.json', 'w') as f:
    # print(data_representation, file=f)
    json.dump(db, f)

with open("database.json", "r") as f:
    # result = json.loads(f.read())
    result = json.load(f)

print(type(result))
result

type(data_representation)
# data_representation['people']
result = json.loads(data_representation)
result['people']
# result['people'][0]
# result['people'][0]['name']

"""# Finding Specific Data in Nested Python Structures Commonly Used in JSON

When working with JSON data in Python, it's common to encounter nested structures composed of dictionaries (`dict`) and lists (`list`). Understanding how to navigate and find specific data within these structures is a valuable skill, especially when dealing with data loaded from JSON files.

### Representation in Python:
The `db` example you provided is a typical representation of JSON-like data in Python. It's a combination of lists and dictionaries, a structure that is not just Python-specific but is also how data is often stored in JSON files:

```python
people = [
    {"name": "Alice Smith", "age": 30, "height": 5.5},
    {"name": "Bob Johnson", "age": 45, "height": 6.1},
    {"name": "Carol Williams", "age": 22, "height": 5.3},
    {"name": "David Brown", "age": 35, "height": 5.9}
]

banks = [
    {'name': 'hapoalim', 'rating': 7},
    {'name': 'discount', 'rating': 8},
    {'name': 'leumi', 'rating': 9}
]

db = {
    'people': people,
    'banks': banks,
}
```

### Finding Specific Data:

#### Task: Find a Bank with a Specific Rating
Suppose you want to find all banks with a rating of **8 or more**.

**How to Do It:**
1. Loop through the `banks` list.
2. For each dictionary in the list, check if the value associated with the key `'rating'` is **8 or more**.
3. If it is, you've found a matching bank.

**Example Code:**
```python
rating_to_find = 8
found_banks = [bank for bank in db['banks'] if bank['rating'] >= rating_to_find]
print("Banks with rating 8 or more:", found_banks)
```

### Understanding the Structure:
- The combination of lists and dictionaries, as seen in this `db`, allows for a representation of data in a structured and hierarchical manner.
- Lists are used for collections of items (like multiple people or banks), while dictionaries are used to represent structured data about a single item (like details of a person or a bank).

By mastering how to search through nested lists and dictionaries, you can effectively handle complex data structures making data manipulation and analysis more efficient and straightforward.

## Exercises

### Exercise 1: Create and Save JSON Data

**Task:** Create a Python dictionary representing a bookstore with different categories of books. Each category should have a list of books, where each book is represented as a dictionary with keys like `title`, `author`, and `price`. Then, save this data to a file in JSON format.

**Steps:**
1. Create a Python dictionary with at least two categories, such as 'Fiction' and 'Non-fiction'.
2. Each category should contain a list of at least two books.
3. Use the `json` module to save this dictionary to a file named 'bookstore.json'.

**Example Structure:**
```python
bookstore = {
    "Fiction": [
        {"title": "To Kill a Mockingbird", "author": "Harper Lee", "price": 8.99},
        {"title": "1984", "author": "George Orwell", "price": 7.99}
    ],
    "Non-fiction": [
        {"title": "Sapiens", "author": "Yuval Noah Harari", "price": 15.99},
        {"title": "Educated", "author": "Tara Westover", "price": 12.99}
    ]
}
```
---

### Exercise 2: Load and Modify JSON Data

**Example Structure in 'employees.json':**
```json
[
    {"name": "John Doe", "position": "Manager", "salary": 50000},
    {"name": "Jane Smith", "position": "Developer", "salary": 60000}
]
```

**Task:** Write a Python script to manage employee data stored in a JSON file named 'employees.json'. If the file doesn't exist, create it with sample data. Load the data, increase each employee's salary by 10%, then save the updated data back to the file.

**Steps:**
1. Check if 'employees.json' exists. If not, create it with sample employee data.
2. Load the employee data from 'employees.json'.
3. Increase each employee's salary by 10%.
4. Print the updated employee data.
5. Save the updated data back to 'employees.json'.

---

> These exercises will help you practice creating, saving, loading, and manipulating JSON data in Python, which are common tasks in many real-world applications involving data handling.
"""



"""# solution"""

### 1

import json

# Creating the bookstore data structure
bookstore = {
    "Fiction": [
        {"title": "To Kill a Mockingbird", "author": "Harper Lee", "price": 8.99},
        {"title": "1984", "author": "George Orwell", "price": 7.99}
    ],
    "Non-fiction": [
        {"title": "Sapiens", "author": "Yuval Noah Harari", "price": 15.99},
        {"title": "Educated", "author": "Tara Westover", "price": 12.99}
    ]
}

# Writing the dictionary to a JSON file
with open('bookstore.json', 'w') as json_file:
    json.dump(bookstore, json_file, indent=4)

### 2

import json

def create_data():
    # Sample data for 'employees.json'
    sample_employees = [
        {"name": "John Doe", "position": "Manager", "salary": 50000},
        {"name": "Jane Smith", "position": "Developer", "salary": 60000}
    ]
    return sample_employees

if not Path('employees.json').exists():
    print('Creating "employees.json" file')
    # Create 'employees.json' with sample data
    with open('employees.json', 'w') as json_file:
        json.dump(create_data(), json_file, indent=4)

# Load JSON data from 'employees.json'
with open('employees.json', 'r') as json_file:
    employees = json.load(json_file)

# Increasing each employee's salary by 10%
for employee in employees:
    employee['salary'] *= 1.10

# Printing the updated list of employees
print("Updated employee data:")
for employee in employees:
    print(employee)

print('saving to "employees.json" file')
with open('employees.json', 'w') as json_file:
    json.dump(employees, json_file, indent=4)

